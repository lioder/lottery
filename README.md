## lottery
一系列抽奖相关的程序，用于学习并发与线程安全，顺便练习一下 Go 语言
#### 引发线程不安全的原因
多个线程同时对共享变量的读写

#### 测试并发的方法
1. 通过 Go 协程和 httptest
2. 通过 wrk 命令行工具
    ```$shell
    wrk -t10 -c10 -d5 http://localhost:8080/lucky
    ```
    开启10个线程，10个TCP连接，测试持续5s，引发『超卖』现象
    
#### 实现线程安全的方法
1. 互斥锁（sync.Mutex）

    当访问共享变量时加锁，访问结束后解锁
    
2. 任务队列

    创建一个任务通道，并维护一个服务（协程），服务按顺序读取任务并执行，将结果放回任务的回调通道中。
    
    另外一个线程创建任务，将任务放入任务通道，并等待回调通道的返回
    
    实现线程安全的原理：服务封装了对共享变量的读取和修改，并且由于通道的引入，服务每次只能执行一个任务，因此避免了并发修改
    
    优化：可以创建并维护多个服务，并通过散列的方式，将任务映射到不同的服务。这种方式需要注意的是任务、通道、共享变量三者要一致。
    
    例如所有相同的红包id通过取余唯一映射到某个服务，在服务中修改这个id对应的共享变量。这样并发的抢统一红包就不会出问题。
    然而有些情况下例如任务A映射到B服务，修改C共享变量，而任务D映射到E服务，修改C共享变量，这种情况下就不能使用这种优化。因为会出现并发修改C共享变量（不同的服务可以并行），只运行一个服务可以解决。